# 61-Day3

## 1 复杂度记号O

最坏情况O，最好情况$\Omega$，渐进复杂度$\Theta$。

## 2 排序算法

### 2.1 快速排序(QuickSort)

- BogoSort随机排序，时间复杂度$O(n\cdot n!)$

- QuickSort: 期望时间复杂度$O(n \log n)$，最坏情况时间复杂度$O(n^2)$.

- 思路：选取一个支点，把小于支点的放在左边，大于支点的放在右边，递归上述过程。

- 时间复杂度分析：$T(n)=T(|L|)+T(|R|)+O(n)$

  期望：每次选到的数大小在中点，$T(n)=2T(n/2)+O(n)$，解得$T(n)=O(n\log n)$

  最坏：每次都选到最大的数，$T(n)=O(n^2)$

- 理论上说，基于比较算法最优时间复杂度是$O(n\log n)$，即MergeSort.

### 2.2 桶排序(BucketSort)
- 思路：不基于比较，把不同大小的数据放在与大小对应的桶里，取排序结果时依次从桶中取出结果。时间复杂度$O(n)$。
  劣：在有特别大的数据时需要很多桶，需要的时间空间都很多。
  
- 改进：RadixSort：对数据的每一位使用桶排序，时间复杂度$O(nd)$，其中d是数据的位数，每一位比较一次时$d=\log_{10}n$，故复杂度为$O(n \log n)$，对于一般情况，n个整数，最大值M，r个桶，$d=\lfloor{\log_r M}\rfloor$，因此总复杂度$O((n+r)\cdot(\lfloor{\log_r M}\rfloor+1)$。

- 在被排序数据不大时可以在$O(n)$时间完成排序。

## 3 数据结构

### 3.1 基本数据结构：Array，List

- 对有序数组：插入/删除：$O(n)$，查找：$O(\log n)$（二分查找）
- 对无序数组：插入/删除：$O(1)$，查找：$O(n)$（需要遍历）
- 对列表：插入/删除较快，但查找较慢
- Motivation of Binary Search Trees: 想在$O(\log n)$时间完成插入/删除和查找

### 3.2 二元搜索树：Binary Search Tree
- Binary Search Tree (BST)：所有左孩子比父亲小，所有右孩子比父亲大。
- 建立BST：选择支点，小于支点的放在左边，大于支点的放在右边，递归上述过程。类似快速排序。BST的构建并不唯一，因为最初节点的选择并不唯一。
- 查找：按照左孩子右孩子和父亲的大小关系依次查找，查找次数为树的高度（最好$O(\log n)$）。
- 插入：与查找类似，找到插入元素大小对应的位置进行插入。
- 删除：如果删除的节点没有孩子，直接删除就好；如果删除的节点只有一个孩子，把孩子提上来就好；如果删除的节点有两个孩子，用比且仅比被删除节点大的节点代替被删除节点。

### 3.3 2-3-4树：2-3-4 Tree

- 分为2节点，3节点和4节点（数字代表孩子的个数），2节点有一个元素，3节点有两个元素，4节点有3个元素，子节点与父节点的大小关系与BST类似——总体从左到右递增。
- 每个叶节点到根节点距离相同——完美平衡。
- 查找：基于比较，与BST类似。
- 插入：找到插入位置后为保证树高度不变，2节点变3节点，3节点变4节点，插入4节点时：分裂（Splitting）——把4节点分裂，把父节点x变成x+1节点后另外两个元素作为此时新的父节点的新的孩子后再进行插入。
### 3.4 红黑树：LLRB Tree

- 把2-3-4树变成二元查找树：通过把3节点和4节点进行拆分，拆分出来的边是红色。
- LLRB Tree: Self-balacing binary search tree.
- 基本思想：把BST通过旋转达到平衡。
- 规定：节点非红即黑；根节点和NIL子节点（叶节点下假想的孩子）为黑；红节点的孩子是黑的；从任意节点到NIL节点经过的黑节点数量相同。
- n个节点的红黑树的最大高度是$2\log (n+1)$.
- 在红黑树中，查找、插入和删除的最坏时间复杂度都是$O(\log n)$.
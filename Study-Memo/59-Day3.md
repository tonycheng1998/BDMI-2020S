# 课程小结

- 复杂度理论和基础排序算法
- 数据结构和二叉搜索树

## 复杂度记号

- 最坏情况（时间复杂度）**O**
- 最好情况  **Ω**
- 渐进复杂度  **Θ**

## 排序算法

- BogoSort（随机排序）
  - 思路：不断随机打乱元素顺序，看是否符合排列顺序
  - 平均时间复杂度O(n·n!)

- **QuickSort**（快速排序）
  - 基于分治法的高效排序算法
  - 思路：选取一个支点，把小于支点的放在左边，大于支点的放在右边，重复
  - T(n)=T(|L|)+T(|R|)+O(n)
    - average case：
      - 复杂度O(n log n)
      - 每次选到的数大小恰在中点，T(n)=2T(n/2)+O(n)，解得T(n)=O(n log n)
    - worst case：
      - 复杂度O(n<sup>2</sup>)
      - 每次都选到最大的数，T(n)=O(n<sup>2</sup>)

- MergeSort（归并排序）
  - 基于比较的算法里，是最优的
  - 最差、平均、最好时复杂度都是`O(n log n)`

- **BucketSort**（桶排序）
  - 思路：不基于比较，遍历序列并把不同大小的数据放在与大小对应的桶里，遍历所有桶并依次取出其中的元素组成排好序的序列；sort on least significant digit, and then the 2<sup>nd</nd>
  - average case O(n log<sub>n</sub>M)（M是最大值）；被排序数据范围不大（不大于数据量）时约为O(n)
  - 缺点：有特别大的数据时需要的时间空间很多

- RadixSort（基数排序，BucketSort改进版）
  - 思路：对数据的每一位使用桶排序
  - 时间复杂度O(nd)（其中d是数据的位数）
    - 每一位比较一次时d=log<sub>10</sub>n，故复杂度为O(n log n)
    - 对于一般情况，n个整数，最大值M，r个桶，d=⌊log<sub>r</sub>M⌋，因此总复杂度O((n+r)·(⌊log<sub>r</sub>M⌋+1))

## 数据结构

- 基本数据结构（Array，List）
  - 有序数组：插入/删除O(n)，搜索O(log n)（二分搜索）
  - 无序数组：插入/删除O(1)，搜索O(n)（遍历）
  - 列表：插入/删除较快，搜索较慢

- **Binary Search Tree**（二叉搜索树）
  - Motivation of BST: O(log n)时间完成插入、删除和搜索
  - 建立：选择支点，小于支点的放在左边，大于支点的放在右边，重复（BST的构建并不唯一，因为最初节点的选择并不唯一）
  - search：所有左子比父小，所有右子比父大；按照左子右子和父的大小关系依次搜索，搜索次数为树的高度（最好情况O(log n)，最坏情况O(n)）
  - insert：与search类似，找到插入元素大小对应的位置进行插入
  - delete：如果删除的节点没有子（是叶子节点），直接删除；如果删除的节点只有一个子，把子提上来；如果删除的节点有两个子，用比且仅比被删除节点大的节点代替被删除节点
  - 缺点：树的不平衡可能导致搜索复杂度大幅提升

- **2-3-4 Tree**（2-3-4树）
  - 多叉树；分为2节点，3节点和4节点（数字代表子节点的个数）——2节点有1个元素，3节点有2个元素，4节点有3个元素
  - 子节点与父节点的大小关系与BST类似——总体从左到右递增
  - 每个叶节点到根节点距离相同——完美**平衡**的树结构，在插入过程中通过节点的分裂和合并实现在维持树的性质的同时保持平衡
  - search：基于比较，与BST类似
  - insert：找到插入位置后为保证树高度不变，2节点变3节点，3节点变4节点，插入4节点时分裂（splitting）——把4节点分裂，把父节点x变成x+1节点后，另外两个元素作为此时新的父节点的新的子，再进行插入
  - 缺点：存在度为3和4的节点，相比二叉树较为复杂

- **LLRB Tree**（红黑树）
  - 把2-3-4树变成二叉搜索树，添加颜色：把3节点和4节点进行拆分，拆分出来的边是红色
  - 把BST通过**旋转**达到平衡；实质为self-balancing binary search tree
  - 在插入元素过程中，通过变色、旋转保持红黑树的规则
  - 规定：节点非红即黑；根节点和叶子节点（NIL）为黑；每个红色节点的两个子节点一定都是黑色；**从任意节点到NIL节点经过的路径都包含数量相同的黑节点**（保证其最坏情况也只是最长边是最短边的两倍）
  - n个节点的红黑树的最大高度是`2 log (n+1)`
  - search（搜索过程和BST相同）、insert和delete的最坏时间复杂度均为O(log n)
